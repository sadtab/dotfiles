# Configurations de XDG
export DOCKER_CONFIG="$XDG_CONFIG_HOME"/docker
export GNUPGHOME="$XDG_DATA_HOME"/gnupg
export NPM_CONFIG_USERCONFIG=$XDG_CONFIG_HOME/npm/npmrc
export XAUTHORITY="$XDG_RUNTIME_DIR"/Xauthority
export WGETRC="$XDG_CONFIG_HOME/wgetrc"

export SUDO_EDITOR=nvim

# Remplacer PS1 de bahcrc,
PS1_FORD='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]ST@$ST_TARGET_MACHINE\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\e[33m\]`my_git_ps1`\[\e[0m\]\n\$ '
export PS1=${PS1_FORD}

RED='\033[0;31m'
BLACK='\033[0;30'
RED='\033[0;31'
GREEN='\033[0;32'
BROWN='\033[0;33'
BLUE='\033[0;34'
PURPLE='\033[0;35'
CYAN='\033[0;36'
LIGHT_GRAY='\033[0;37'
DARK_GRAY='\033[1;30'
LIGHT_RED='\033[1;31'
LIGHT_GREEN='\033[1;32'
YELLOW='\033[1;33'
LIGHT_BLUE='\033[1;34'
LIGHT_PURPLE='\033[1;35'
LIGHT_CYAN='\033[1;36'
WHITE='\033[1;37'
NC='\033[0m' # No Color

if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
fi
if [ -d "$HOME/go/bin" ] ; then
    PATH="$HOME/go/bin:$PATH"
fi

# vim builtin terminal fix
if [ ! -z "$MYVIMRC" ] && [ -f "/etc/profile.d/vte-2.91.sh" ] ; then
    source /etc/profile.d/vte-2.91.sh
fi

# Licence d'EB
ST_LICENSE_ADMIN_TAR_GZ="$HOME/Documents/EB_corbos/License/EB_Client_License_Administrator_1_4_3_Linux.tar.gz"
ST_LICENSE_KEY_TXT="$HOME/Documents/EB_corbos/License/eb_license_key.txt"

# Docker image versions
EB_DOCKER="local_adg2.13_eblinux:latest"
WR_DOCKER="local_adg2.13_wrlinux:latest"
QX_DOCKER="local_adg2.13_qnx:latest"

EB_DOCKER_NEXUS="registry.ford.com/fnv-swdev/fnv4_build_tools_eb2.13-eblinux:latest"
WR_DOCKER_NEXUS="registry.ford.com/fnv-swdev/fnv4_build_tools_eb2.13-wrlinux:latest"
QX_DOCKER_NEXUS="registry.ford.com/fnv-swdev/fnv4_build_tools_eb2.13-qnx-arm64:latest"

# Configurations des workspaces
HOST_WORKSPACE="$HOME/host_workspace"

declare -A     WT=(
    [SWU]="worktree_swu" \
    [SW2]="worktree_sw2" \
    [SW3]="worktree_sw3" \
    [OTA]="worktree_ota" \
    [OT2]="worktree_ot2" \
    [DTM]="worktree_dtm" \
    [SMP]="worktree_smp" \
    [DEM]="worktree_dem" \
    [NET]="worktree_net" \
    [VPS]="worktree_vps" \
    [DIA]="worktree_dia" \
    [CCS]="worktree_ccs" \
    [CCI]="worktree_cci" \
    [PYT]="worktree_pyt" \
    [STM]="worktree_stm" \
    [BAS]="worktree_bas" \
    [MAN]="worktree_man" \
    [TST]="worktree_tst" \
    [YOC]="worktree_yoc" \
    [YOW]="worktree_yow" \
    [TMP]="worktree_tmp" \
    [V2X]="worktree_v2x" )

# Optionelle
declare -A   REPO=(
    [SWU]="software-update-tools" \
    [SW2]="software-update-tools" \
    [SW3]="software-update-tools" \
    [OTA]="software-update-ota" \
    [OT2]="software-update-ota" \
    [DTM]="datatransfermanager" \
    [SMP]="samples" \
    [NET]="networking" \
    [DEM]="demo" \
    [VPS]="vpsm" \
    [DIA]="diagnostics" \
    [CCS]="ccs" \
    [CCI]="cloud-communication-interface" \
    [PYT]="python-binding" \
    [STM]="statemanagement" \
    [BAS]="base" \
    [V2X]="v2x")

# Optionelle
declare -A    APP=(
    [SWU]="swu-tools" \
    [SW2]="swu-tools" \
    [SW3]="swu-tools" \
    [OTA]="vsp_os_swu_ota" \
    [OT2]="vsp_os_swu_ota" \
    [DTM]="DTM" \
    [SMP]="samples" \
    [NET]="CM" \
    [DEM]="demo" \
    [VPS]="vpsm_server" \
    [DIA]="vdm" \
    [CCS]="manager" \
    [CCI]="cci" \
    [V2X]="v2x-services")

# Detecter le workspace mont√© dans le contenaire
function where_am_i() {
    if [ -f /.dockerenv ];
    then
        for xxx in ${!WT[*]};do
            if [[ ! -z ${REPO[$xxx]} && -d $HOST_WORKSPACE/${WT[$xxx]}/${REPO[$xxx]} ]];then
                #Names of directory
                CURRENT_WT=${WT[$xxx]}
                CURRENT_REPO=${REPO[$xxx]}
                CURRENT_APP=${APP[$xxx]}
                CURRENT_APP_ABRV=$xxx

                # Absolute path of directory
                export CURRENT_WT_PATH=${HOST_WORKSPACE}/${CURRENT_WT}
                export CURRENT_REPO_PATH=${HOST_WORKSPACE}/${CURRENT_WT}/${CURRENT_REPO}
                export CURRENT_APP_PATH=${HOST_WORKSPACE}/${CURRENT_WT}/${CURRENT_REPO}/${CURRENT_APP}
            fi
        done

    else
        echo " where_am_i Oups : On est pas dans un contenaire"
        CURRENT_REPO_PATH=""
        MY_APP_PATH_HOST=""
        CURRENT_APP_PATH=""
    fi
}

# Selecteurs de contenaire
# Avec raccourcis
function usage_dk() {
cat << EOF
    Quel image de docker ?

    Repo            Platform:
    ---------       ---------
    SWU     s       EBlinux   None
    SW2     S       WRlinux   w
    SW3     W       QNX-arm64 q
    OTA     o
    OT2     O
    YOW     Y

    Exemple :
    s           (SWU in EB)
    S           (SW2 in EB)
    ow          (OTA in WRLinux)
    Sq          (SW2 in QNX-arm64)
EOF
}

function dk(){
    if [ -f /.dockerenv ]; then echo "Pas dispo dans un contenaire"; return; fi

    if [ ! -z "$1" ];then
        REPLY="$1"
    else
        usage_dk
        read
    fi

    workspace=${REPLY:0:1}
    case $workspace in
        's')   target="SWU";;
        'S')   target="SW2";;
        'W')   target="SW3";;
        'o')   target="OTA";;
        'O')   target="OT2";;
        'Y')   target="YOW";;
        *) echo -e "Choix invalide"; return ;;
    esac

    # First three letters are target and the second letter of REPLY is the platform
    DK ${target}${REPLY:1:1}
}

alias dks='dk s'
alias dko='dk o'

function usage_DK() {
cat << EOF
    Quel image de docker ?

    Platform:
    ---------
    EBlinux   None
    WRlinux   w
    QNX-arm64 q

    Exemple :
    XXX           (XXX in EB)
    XXXw          (XXX in WRLinux)
    XXXq          (XXX in QNX-arm64)
EOF
}

function DK() {
    if [ -f /.dockerenv ]; then echo "Pas dispo dans un contenaire"; return; fi

    if [ ! -z "$1" ];then
        REPLY="$1"
    else
        ls $HOST_WORKSPACE
        usage_DK
        read
    fi

    target=${REPLY:0:3} # First three letters are target and the second letter of REPLY is the platform
    target=${target^^}  # Capitalize if lowercase

    target_workspace="$HOME/host_workspace/${WT[$target]}"

    if ! exists $target in WT; then echo "$target is not in WT dictionary"; return; fi

    if [ -z ${REPLY:3:1} ]; then
        docker_image=$EB_DOCKER
    elif [[ ${REPLY:3:1} == "w" ]]; then
        docker_image=$WR_DOCKER
    elif [[ ${REPLY:3:1} == "q" ]]; then
        docker_image=$QX_DOCKER
    else
        echo -e "Choix de docker image est invalide"; return
    fi

    doky $docker_image $target_workspace
}

# Pilot de run_docker.sh
function doky() {
    docker_image=$1
    target_workspace=$2

    echo "Docker pour image $docker_image, montage de $target_workspace"

    RUN_DOCKER="$HOME/host_workspace/worktree_swu/BuildTools/scripts/run_docker.sh"

    $RUN_DOCKER                                                                         \
        -x11                                                                            \
        -k                                                                              \
        -i $docker_image                                                                \
        -w $HOST_WORKSPACE/LaPorte                                                      \
        -v $target_workspace:$target_workspace                                          \
        -v $HOME/clangd:$HOME/clangd                                                    \
        -v $HOME/.ssh:$HOME/.ssh                                                        \
        -v $HOME/.bashrc:$HOME/.bashrc                                                  \
        -v $HOME/.sudo_as_admin_successful:$HOME/.sudo_as_admin_successful              \
        -v $HOME/dotfiles:$HOME/dotfiles                                                \
        -v $HOME/.config/docker_config_folder:$HOME/.config                             \
        -v $HOME/.config/git:$HOME/.config/git                                          \
        -v $HOME/.config/git/config:$HOME/.config/git/config                            \
        -v $HOME/.config/git/gitconf_machine:$HOME/.config/git/gitconf_machine          \
        -v $HOME/.local/state/bash/history:$HOME/.local/state/bash/history              \
        -v $HOME/.local/share/vim/:$HOME/.local/share/vim                               \
        -v $HOME/.local/share/recently-used.xbel:$HOME/.local/share/recently-used.xbel  \
        --reset-entrypoint
}

function doky_pull_all() {
    # Login first  : (No VPN or Zscaler)
    #   docker login -u=stabei -p=<generated> registry.ford.com
    # Or
    #   docker login registry.ford.com
    echo ">>> Pulling $EB_DOCKER_NEXUS"
    docker pull $EB_DOCKER_NEXUS
    echo ">>> Pulling $WR_DOCKER_NEXUS"
    docker pull $WR_DOCKER_NEXUS
    echo ">>> Pulling $QX_DOCKER_NEXUS"
    docker pull $QX_DOCKER_NEXUS
}

function doky_rmi_locals() {
    docker rmi -f $QX_DOCKER
    docker rmi -f $EB_DOCKER
    docker rmi -f $WR_DOCKER

    # Clean existing images
    docker image prune
    docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
    docker images
}

function doky_prune(){
    docker image prune
    docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
}

function doky_image_build(){
    cat << EOF
    Quel image de docker ?

    EBLinux  e
    WRLinux  w
    QNX(ARM) q

    -- If permission issue :
    sudo apt install docker.io=20.10.21-0ubuntu1~20.04.2
EOF

    RUN_DOCKER="$HOME/host_workspace/worktree_swu/BuildTools/scripts/run_docker.sh"

    read
    case $REPLY in
        'w')
            docker rmi -f $WR_DOCKER 2>/dev/null
            echo "Creation image WR avec [worktree_swu/BuildTools], rassurer que SWU s'est bien √† jour"
            sleep 2s

            $RUN_DOCKER \
                -b $WR_DOCKER_NEXUS \
                -i $WR_DOCKER \
                -w $HOST_WORKSPACE/worktree_swu

             # Enlever dangling images
             docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
             return ;;

         'q')
             docker rmi -f $QX_DOCKER 2>/dev/null
            echo "Creation image QNX avec [worktree_swu/BuildTools], rassurer que SWU s'est bien √† jour"
             sleep 2s

             $RUN_DOCKER \
                 -b $QX_DOCKER_NEXUS \
                 -i $QX_DOCKER \
                 -w $HOST_WORKSPACE/worktree_swu

             # Enlever dangling images
             docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
             return ;;

         'e')
             # For Studio in EB
             # sudo sh -c 'echo 1 > /proc/sys/net/ipv6/conf/eno1/disable_ipv6'

             docker rmi -f $EB_DOCKER 2>/dev/null
             echo "Creation image EB avec [worktree_swu/BuildTools], rassurer que SWU s'est bien √† jour"
             sleep 2s

             # Creer un image temporaire
             $RUN_DOCKER \
                 -b $EB_DOCKER_NEXUS \
                 -i $EB_DOCKER \
                 -w $HOST_WORKSPACE/worktree_swu

             # Creer un image avec license depuis l'image temporaire
             # $HOST_WORKSPACE/worktree_swu/BuildTools/scripts/EB_Client_License/activate_eb_client_license.sh \
             #     --target-os eblinux \
             #     -b eb_temp:latest \
             #     -i $EB_DOCKER \
             #     -l $ST_LICENSE_ADMIN_TAR_GZ \
             #     -k $ST_LICENSE_KEY_TXT

             # Enlever l'image temporaire
             # docker rmi -f eb_temp:latest

             # Enlever dangling images
             docker rmi $(docker images --filter "dangling=true" -q --no-trunc)
             return ;;
         *) echo -e "Invalid choice"; return ;;
     esac
}

# Toggle the proxy
function px(){
    if [ ! -z $http_proxy ];then
        echo "Proxy unset"
        unset {http,https,ftp}_proxy
        unset {HTTP,HTTPS,FTP}_PROXY
    else
        echo "Proxy set"
        export {http,https,ftp}_proxy="http://internet.ford.com:83/"
        export {HTTP,HTTPS,FTP}_PROXY="http://internet.ford.com:83/"
    fi

}

# Pilot de build script
function bl(){
    where_am_i
    if [ -z "$CURRENT_APP_PATH" ]; then
        echo "where_am_i didn't set"
        return
    fi
    if [ ! -z "$1" ];then
        REPLY="$1"
    else
        cat << EOF
./build.sh :
        -n | No argument
        -b | --build
        -c | --clean
        -a | --all
        -d | --deploy
        -g | --generate
        -o | --out-container
        -s | --scan
        -t | --test
        -u | --build-test
        -x | --coverage
        -h | --help
EOF

        read
    fi
    case $REPLY in

        'n') pushd $CURRENT_REPO_PATH;./build.sh   ;popd; return ;;
        'g') pushd $CURRENT_REPO_PATH;./build.sh -g;popd; return ;;
        'b') pushd $CURRENT_REPO_PATH;./build.sh -b;popd; return ;;
        'a') pushd $CURRENT_REPO_PATH;./build_dependencies.sh
                                      ./build.sh   ;popd; return ;;
        'c') pushd $CURRENT_REPO_PATH;./build.sh -c;popd; return ;;
        'd') pushd $CURRENT_REPO_PATH;./build.sh -d;popd; return ;;
        'g') pushd $CURRENT_REPO_PATH;./build.sh -g;popd; return ;;
        'o') pushd $CURRENT_REPO_PATH;./build.sh -o;popd; return ;;
        's') pushd $CURRENT_REPO_PATH;./build.sh -s;popd; return ;;
        't') pushd $CURRENT_REPO_PATH;./build.sh -t;popd; return ;;
        'u') pushd $CURRENT_REPO_PATH;./build.sh -u;popd; return ;;
        'x') pushd $CURRENT_REPO_PATH;./build.sh -x;popd; return ;;
        'h') pushd $CURRENT_REPO_PATH;./build.sh -h;popd; return ;;
        *) echo $REPLY
            echo -e "Invalid choice"; return ;;
    esac
}

alias bla='bl a'
alias blb='bl b'
alias bln='bl n'
alias blo='bl o'
alias bld='bl d'
alias blt='bl t'
alias blu='bl u'
alias blx='bl x'


# Clean Pull tous
function new_sprint(){
    for xxx in ${!WT[*]};do
        if [ -d $HOST_WORKSPACE/${WT[$xxx]} ];then
            #Names of directory
            wt=${WT[$xxx]}

            # Absolute path of directory
            current_wt_path=${HOST_WORKSPACE}/${wt}

            # Exception pour yow and yoc
            if [[ "${wt}" == "worktree_yoc" || "${wt}" == "worktree_yow" ]];then
                    repo forall -c 'git reset --hard'
                    repo forall -c 'git clean -xdf'
                    repo forall -c 'git gc --prune=now'
                    repo forall -c 'git remote prune origin'
                    repo forall -c 'git checkout master'
                    repo sync
                    if [ -d current_wt_path/build ];then
                        rm -rf  current_wt_path/build
                    fi
            elif [ -d ${HOST_WORKSPACE}/${wt}/.repo ];then
                pushd $current_wt_path
                    repo forall -c 'git reset --hard'
                    repo forall -c 'git clean -xdf'
                    repo forall -c 'git checkout master'
                    repo forall -c 'git gc --prune=now'
                    repo forall -c 'git remote prune origin'
                    repo forall -c 'git checkout master'
                    repo forall -c 'git pull'
                popd
            fi
        fi
    done
}

# Connecter/D√©connecter √† Cisco
function cisco() {
    [ -f /.dockerenv ] && { echo "In a docker" ; return ; }

    if [ "$(/opt/cisco/anyconnect/bin/vpn state | grep -c Connected )" -ge 1 ]
    then
        while true; do
            read -p "Cisco est d√©j√† connect√©, D√©connecter-le ? [Y/N]" RESP
            case $RESP in
                [Yy]* ) /opt/cisco/anyconnect/bin/vpn disconnect; break;;
                [Nn]* ) return;;
                * ) echo "yes or no.";;
            esac
        done
    elif [ "$(/opt/cisco/anyconnect/bin/vpn state | grep -c Disconnected )" -ge 1 ]
        then
        echo "Cisco n'est pas connect√©, pr√©pare le token RSA..."
        /opt/cisco/anyconnect/bin/vpn connect "Ford - North America"
    fi
}

# Lancer les test unitaire
# run all tests             : ts
# run filtered test         : ts "PATTERN"
# run filtered test N times : ts "PATTERN" N
# run filtered test N times : ts "PATTERN" N
#   By default it wont break at failure other wise specify the number
# run filtered test  (Break at failure)         : ts "PATTERN" 1
# run filtered test  (Don't Break at failure)   : ts "PATTERN"
# In case of issue test with
#                                               GTEST_FILTER="PATTERN" blt
function ts() {
    set +e
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
    PATTERN=$1
    REPEATS=$2

    # Default pattern
    if [[ -z $PATTERN ]]; then
        PATTERN="*"
    fi

    where_am_i

    if [[ -z "$CURRENT_APP_PATH" ]]; then
        echo "where_am_i didn't set"
        return
    fi

    if [[ "$VSP_TARGET_PLATFORM" == ADG_EBLINUX ]]; then
        ARA_CLI_OS=EBLinux
        ARA_CLI_PLATFORM=qemu-x86
    elif [[ "$VSP_TARGET_PLATFORM" == ADG_WRLINUX ]]; then
        ARA_CLI_OS=Custom
        ARA_CLI_PLATFORM=qemu-arm64
    else
        echo Invalid VSP_TARGET_PLATFORM = $VSP_TARGET_PLATFORM
        return;
    fi

    #Set default values
    BREAK="--gtest_break_on_failure"
    if [[ -z $REPEATS ]];then
        REPEATS="1"
        BREAK=""
    fi

    # Car base/set-env.sh est m√©rdique
    export BASE_FRAMEWORK_PATH="$HOST_WORKSPACE/$CURRENT_WT/base"
    export CMAKE_PREFIX_PATH="$BASE_FRAMEWORK_PATH/config/cmake/"
    export FNV4BASE_ROOT_DIR="$HOST_WORKSPACE/$CURRENT_WT/base"
    export fnvbase_ROOT_DIR="$FNV4BASE_ROOT_DIR/fnvbase/studio/fnvbase/usr"
    export fnvbaseutils_ROOT_DIR="$FNV4BASE_ROOT_DIR/fnvbaseutils/studio/fnvbaseutils/usr"
    export aracom_helper_ROOT_DIR="$FNV4BASE_ROOT_DIR/aracom_helper/studio/aracom_helper/usr"
    export FNV4ARAGMOCK_ROOT_DIR="$HOST_WORKSPACE/$CURRENT_WT/ara-gmock"
    export FRANCA_ROOT_DIR="$HOST_WORKSPACE/$CURRENT_WT/franca"
    export BUILDCMAKEMODULES_ROOT_DIR="$HOST_WORKSPACE/$CURRENT_WT/BuildCMakeModules"

    APP_DIR=${CURRENT_APP_PATH}
    BUILD_DIR=${CURRENT_APP_PATH}/build

    ara-cli Application \
        --app               $APP_DIR \
        --cpus              14 \
        --build-dir         $BUILD_DIR \
        --target-os         $ARA_CLI_OS \
        --target-platform   $ARA_CLI_PLATFORM \
        --workspace         $BUILD_DIR/ara_workspace \
        --gtest-options="--gtest_filter=$PATTERN --gtest_repeat=$REPEATS --gtest_color=yes $BREAK " \
        --run-tests

}

# Lancer EB_Corbos_Studio
function ebs() {
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
    where_am_i
    echo "workspace : $CURRENT_APP_PATH"
    /bin/bash /tmp/studio_entrypoint.sh  > /dev/null 2>&1 &
}

# Pilot de Qemu
function qm(){
    cat << EOF
Qemu  ?

    Start       1/2         (Docker only)

    Stop        11/22       (Docker only)

    Restart     r/rr        (Docker only)

    SSH         s/ss
EOF

# TODOST Revise the whole IP adress

if [[ $VSP_TARGET_PLATFORM == "ADG_QNX" ]]; then
    CPUS="1"
    EXTRA_OPTIONS=""
    IP1="root@10.1.0.101"
    IP2="root@10.1.0.102"
    CD_DATA=""
    SLEEP="sleep 1s"
else
    CPUS="14"
    EXTRA_OPTIONS="--kvm"
    IP1="root@10.1.0.1"
    IP2="root@10.1.0.2"
    CD_DATA="cd /data/; bash -l"
    SLEEP=""
fi

    if [ ! -z "$1" ];then
        REPLY="$1"
    else
        read
    fi
    case $REPLY in

        '1')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            [[ $VSP_TARGET_PLATFORM == "ADG_WRLINUX" ]] && { echo "Use wrqm to run the qemu" ; return ; }
            ara-network -a -N 1
            echo [EXECUTING] ara-cli RunQemu --start 1 --target-platform $VSP_TARGET_ARCH --guest-cpus $CPUS $EXTRA_OPTIONS
            ara-cli RunQemu --start 1 --target-platform $VSP_TARGET_ARCH --guest-cpus $CPUS $EXTRA_OPTIONS
            $SLEEP
            scp -o StrictHostKeyChecking=no ${HOME}/dotfiles/configs/Environments/Ford/bash_qemu $IP1:/data/bash_qemu
            return ;;
        '2')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            [[ $VSP_TARGET_PLATFORM == "ADG_WRLINUX" ]] && { echo "Use wrqm to run the qemu" ; return ; }
            ara-network -a -N 2
            echo [EXECUTING] ara-cli RunQemu --start 2 --target-platform $VSP_TARGET_ARCH --guest-cpus $CPUS $EXTRA_OPTIONS
            ara-cli RunQemu --start 2 --target-platform $VSP_TARGET_ARCH --guest-cpus $CPUS $EXTRA_OPTIONS
            $SLEEP
            scp -o StrictHostKeyChecking=no ${HOME}/dotfiles/configs/Environments/Ford/bash_qemu $IP2:/data/bash_qemu
            return ;;
        '11')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            echo [EXECUTING] ara-cli RunQemu --stop 1 --clean
            ara-cli RunQemu --stop 1 --clean
            ara-network -r -N 1
            return ;;
        '22')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            echo [EXECUTING] ara-cli RunQemu --stop 2 --clean
            ara-cli RunQemu --stop 2 --clean
            ara-network -r -N 2
            return ;;
        'r')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            [[ $VSP_TARGET_PLATFORM == "ADG_WRLINUX" ]] && { echo "Use wrqm to run the qemu" ; return ; }
            echo [EXECUTING] ara-cli RunQemu --restart --start 1 --target-platform $VSP_TARGET_ARCH
            ara-cli RunQemu --restart --start 1 --target-platform $VSP_TARGET_ARCH
            return ;;
        'rr')
            [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
            [[ $VSP_TARGET_PLATFORM == "ADG_WRLINUX" ]] && { echo "Use wrqm to run the qemu" ; return ; }
            echo [EXECUTING] ara-cli RunQemu --restart --start 2 --target-platform $VSP_TARGET_ARCH
            ara-cli RunQemu --restart --start 2 --target-platform $VSP_TARGET_ARCH
            return ;;
        's')
            ssh -o StrictHostKeyChecking=no -t $IP1 $CD_DATA
            return ;;
        'ss')
            ssh -o StrictHostKeyChecking=no -t $IP2 $CD_DATA
            return ;;
        *) echo $REPLY
            echo -e "Invalid choice"; return ;;
    esac
}

# pilote de cd
function c() {
    cat << EOF
cd to :

    SWU   s       |       PYT       p
    SW2   S       |       TST  SWU  t
    SW3   W       |       TST  OTA  T
    OTA   o       |       Yocto WR  Y
    OT2   O       |

    dotfiles        d
    notes           n
EOF

    read
    case $REPLY in

        's')
            cd $HOST_WORKSPACE/${WT[SWU]}/software-update-tools
            return ;;
        'S')
            cd $HOST_WORKSPACE/${WT[SW2]}/software-update-tools
            return ;;
        'W')
            cd $HOST_WORKSPACE/${WT[SW3]}/software-update-tools
            return ;;
        'o')
            cd $HOST_WORKSPACE/${WT[OTA]}/software-update-ota
            return ;;
        'O')
            cd $HOST_WORKSPACE/${WT[OT2]}/software-update-ota
            return ;;
        'p')
            cd $HOST_WORKSPACE/${WT[PYT]}/python-binding/
            return ;;
        't')
            cd $HOST_WORKSPACE/worktree_tst/software-update-tools
            return ;;
        'T')
            cd $HOST_WORKSPACE/worktree_tst/software-update-ota
            return ;;
        'Y')
            cd $HOST_WORKSPACE/worktree_yow/vsp-layers/meta-fordos/recipes-platform
            return ;;
        *) echo $REPLY
            echo -e "Invalid choice"; return ;;
    esac
}

# sed pour codes sources de CPP
function sedC() {
    if [ -z "$1" ];
    then
        echo "Usage : sedC PATTERN REPLACANT"
    else
        find . -type f \( -name '*.cpp' -o -name '*.hpp' \) -print0 | \
        xargs -0 sed -i "s/$1/$2/g"
    fi
}

########################
### Functional test suit
########################

function t_set_env() {
    echo "TODOST : Qemu IP Adress is chnaged, update this helper"
    PB_DIR=${HOST_WORKSPACE}/worktree_tst/python-binding/
    TEST_IP="192.168.7.1"

    echo "s or o ?"
    read
    case $REPLY in
        'o')
            TEST_APP_NAME="OTA"
            APP_TEST_SCRIPT_DIR=${HOST_WORKSPACE}/worktree_tst/software-update-ota/scripts/
            APP_TESTS_DIR=${HOST_WORKSPACE}/worktree_tst/software-update-ota/tests/
            return ;;
        's')
            TEST_APP_NAME="SWU"
            APP_TEST_SCRIPT_DIR=${HOST_WORKSPACE}/worktree_tst/software-update-tools/scripts/
            APP_TESTS_DIR=${HOST_WORKSPACE}/worktree_tst/software-update-tools/tests/
            return ;;

        *) echo -e "Invalid choice"; return ;;
    esac
}

# Usage : copy python-binding.tar.gz in ${PB_DIR} then invoke t_untar_pb()
function t_untar_pb(){
    echo "TODOST : Qemu IP Adress is changed, update this helper"
    t_set_env

    # 1) untaring :
    tar -xvf ${PB_DIR}/python-binding*.tar.gz -C ${PB_DIR} 

    # 2) untaring  the artifacts
    tar -xvf ${PB_DIR}/artifact/PythonBinding_artifacts.tar.gz -C ${PB_DIR}/artifact 

    # 3) change the target qemu
    if [ -f ${PB_DIR}/artifact/PythonBinding/project_config.json ];
    then
        echo "Changing the target qemu from 2 to 1"
        sed -i "s/192.168.7.2/192.168.7.1/g" ${PB_DIR}/artifact/PythonBinding/project_config.json
    else
        echo "${PB_DIR}/artifact/PythonBinding/project_config.json not found"
    fi
}

function t_deploy_pb(){
    echo "TODOST : Qemu IP Adress is chnaged, update this helper"
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
    t_set_env
    ara-cli TargetOperation --app-dir ${PB_DIR}/artifact/PythonBinding
    ara-cli DeployAppContainer --container ${PB_DIR}/artifact/PythonBinding.eb-container-squashfs --target ${TEST_IP}
}

# Usage : in dkt, to be invoked from the same directory as the test script
function t_copy_tests(){
    t_set_env

    ssh -o StrictHostKeyChecking=no root@${TEST_IP} "mkdir -p /data/functional_test_${TEST_APP_NAME}/scripts"
    scp -r -o StrictHostKeyChecking=no ${APP_TEST_SCRIPT_DIR}/* root@${TEST_IP}:/data/functional_test_${TEST_APP_NAME}/scripts
    ssh -o StrictHostKeyChecking=no root@${TEST_IP} "runc exec PythonBinding cp -r /data/functional_test_${TEST_APP_NAME}/scripts /tmp"

    # if slash was ever available
    # ssh -o StrictHostKeyChecking=no root@${TEST_IP} 'mkdir -p /data/functional_test/tests'
    # scp -r -o StrictHostKeyChecking=no ${APP_TESTS_DIR}/*       root@${TEST_IP}:/data/functional_test/tests
}

function t_swp(){
    t_set_env
    ssh -o StrictHostKeyChecking=no root@${TEST_IP} 'mkdir -p /data/SoftwarePackages/'
    scp -r -o StrictHostKeyChecking=no ${HOME}/host_workspace/worktree_tst/software-update-tools/software_packages/* root@${TEST_IP}:/data/SoftwarePackages/
}

########################
### Aliases
########################
alias repof='repo forall -c'
alias repost="repof 'echo -----------------REPO && git rev-parse --show-toplevel && echo ---------------STATUS  && git st '"
alias vbf="nvim ~/dotfiles/configs/Environments/Ford/.bash_ford"
alias sbf="source ~/dotfiles/configs/Environments/Ford/.bash_ford"
alias nd="neovide"

function wrqm(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }

    sudo ln -fs /home/dev/wrlinux_image ${HOME_DIR}/wrlinux_image
    sleep 2s
    ara-network -a -N 1
    sleep 2s
    source /home/dev/ara/eb/adaptivecore/sdk/custom/qemu-arm64/2.13.0-20-11/environment-setup-cortexa57-wrs-linux
    sleep 2s

    # Only for yocto
    # sudo sed -i 's/@TAP@/ara_tap1/' ~/wrlinux_image/qemu-wrlinux-image-core-qemuarm64.qemuboot.conf
    # sudo sed -i 's/@CLIENT@/1/'     ~/wrlinux_image/qemu-wrlinux-image-core-qemuarm64.qemuboot.conf

    runqemu nographic qemuparams="-m 2048M" ~/wrlinux_image/qemu-wrlinux-image-core-qemuarm64.qemuboot.conf
    sleep 2s

    # Do it a second time
    source /home/dev/ara/eb/adaptivecore/sdk/custom/qemu-arm64/2.13.0-20-11/environment-setup-cortexa57-wrs-linux
    sleep 2s
    runqemu nographic qemuparams="-m 2048M" ~/wrlinux_image/qemu-wrlinux-image-core-qemuarm64.qemuboot.conf
}

function yt_all(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }

    ara-cli EBLinux                                                                                         \
        --target-platform qemu-x86                                                                          \
        --add-layer $(realpath meta-eblinux-patches),$(realpath meta-fordos),$(realpath meta-fordos2eblinux)\
        --meta-directory $(realpath eb-linux)                                                               \
        --extra-conf $(realpath nexus_mirror.conf)                                                          \
        --ara-config-params="-l ara --srcrev --abupd --ipv4"                                                \
        --bitbake core-image-eb-dev
}

function yt_swu(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }

    ara-cli EBLinux                                                                                         \
        --target-platform qemu-x86                                                                          \
        --add-layer $(realpath meta-eblinux-patches),$(realpath meta-fordos),$(realpath meta-fordos2eblinux)\
        --meta-directory $(realpath eb-linux)                                                               \
        --extra-conf $(realpath nexus_mirror.conf)                                                          \
        --ara-config-params="-l ara --srcrev --abupd --ipv4"                                                \
        --bitbake "software-update-tools"
}

function yt_ota(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }

    ara-cli EBLinux                                                                                         \
        --target-platform qemu-x86                                                                          \
        --add-layer $(realpath meta-eblinux-patches),$(realpath meta-fordos),$(realpath meta-fordos2eblinux)\
        --meta-directory $(realpath eb-linux)                                                               \
        --extra-conf $(realpath nexus_mirror.conf)                                                          \
        --ara-config-params="-l ara --srcrev --abupd --ipv4"                                                \
        --bitbake "software-update-ota"
}

function yt_cci(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }

    ara-cli EBLinux                                                                                         \
        --target-platform qemu-x86                                                                          \
        --add-layer $(realpath meta-eblinux-patches),$(realpath meta-fordos),$(realpath meta-fordos2eblinux)\
        --meta-directory $(realpath eb-linux)                                                               \
        --extra-conf $(realpath nexus_mirror.conf)                                                          \
        --ara-config-params="-l ara --srcrev --abupd --ipv4"                                                \
        --bitbake "cloud-communication-interface"
}

function bb_swu(){
    [ ! -f /.dockerenv ] && { echo "Not in a docker" ; return ; }
    bitbake software-update-tools
}

### Usages
function h() {
    cat << EOF
    Custom aliases & functions :"

    Docker :
    dk                  : Pilote de docker
    DK                  : Pilote de docker Generique
    doky_pull_all       : Pull tous les images depuis registery
    doky_rmi_locals     : Supprimer tous les images locales
    doky_image_build    : Pilote pour builder
    doky_prune          : Supprimmer danglings
    dks                 : docker launcher for swu
    dko                 : docker launcher for ota

    bl                  : Pilote de build.sh script avec raccourcis < bla blb bln bld blt blx >
    ts                  : Build unit tests and run (only in a docker)
        ts              : run all tests             (No Break at failure, final report)
        ts "PATTERN"    : run filtered test         (No Break at failure, final report)
        ts "PATTERN" N  : run filtered test N times (Break at failure)
        ts "PATTERN" 1  : run filtered test 1 time  (Break at failure)

    t_untar_pb          : untar PythonBinding
    t_untar_app         : untar SWU/OTA
    t_deploy_pb         : deploy PythonBinding
    t_deploy_app        : deploy SWU/OTA
    t_swp               : Copy software packages to /data/SoftwarePackages/
    t_copy  "FILE"      : scp the file to the /data/test directory of qemu

    c                   : cd switch

    qm                  : Qemo driver
    wrqm                : Qemo driver (for wr linux)

    new_sprint          : Clean, checkout master, pull all worktrees
    ebs                 : Run EB Studio            (Only in a docker)
    sedC                : sedC PATTERN REPLACEMENT (for cpp and hpp files, recursively)"

    vbf                 : vim ~/.bash_ford"
    sbf                 : source ~/.bash_ford"

    cisco               : Cisco connection toggle
    px                  : proxy toggle (set/unset)

    yt_all              : Aliase to build yocto
    yt_cci              : Aliase to build yocto
    yt_swu              : Aliase to build yocto
    yt_ota              : Aliase to build yocto
    yt_cci              : Aliase to build yocto
EOF
}

### Helpers
exists(){
    # Usage : if ! exists key in array; then echo "No such array element"; fi
    if [ "$2" != in ]; then
        echo "Incorrect usage."
        echo "Correct usage: exists {key} in {array}"
        return
    fi
    eval '[ ${'$3'[$1]+muahaha} ]'
}


### Post executions
if [ -f /.dockerenv ]; then
    contenaire="EB"

    # Git git_ps1__ definition
    if [ -e /etc/bash_completion.d/git-prompt  ]
    then
        source /etc/bash_completion.d/git-prompt
    fi

    alias nvim="vim -u NONE"

    # Definition de git_ps1
    if [ -f $HOME/.local/share/git-prompt.sh ]; then
        source $HOME/.local/share/git-prompt.sh
    fi

    # git auto completion
    if [ -f /usr/share/bash-completion/completions/git ]; then
        source /usr/share/bash-completion/completions/git
    fi

    if [ -f $HOME/ara/eb/adaptivecore/sdk/qnx/qemu-arm64/qnx710_3/qnxsdp-env.sh ]; then
        source $HOME/ara/eb/adaptivecore/sdk/qnx/qemu-arm64/qnx710_3/qnxsdp-env.sh
        contenaire="QNX"
    fi

    if [ -d /home/dev/wrlinux_image ]; then
        contenaire="WR"
    fi

    export TERM="xterm-256color"
    where_am_i
    if [[ -d "$CURRENT_REPO_PATH" ]]; then
        cd "$CURRENT_REPO_PATH"
    fi

    # Rappele moi que je suis dans le contenaire
    PS1="\e[0;34müê≥(${contenaire}-${CURRENT_APP_ABRV})\e[0m$PS1"
fi

